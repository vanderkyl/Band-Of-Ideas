(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@babel/runtime/helpers/toConsumableArray')) :
    typeof define === 'function' && define.amd ? define(['@babel/runtime/helpers/toConsumableArray'], factory) :
    (global = global || self, factory(global._toConsumableArray));
}(this, (function (_toConsumableArray) { 'use strict';

    _toConsumableArray = _toConsumableArray && _toConsumableArray.hasOwnProperty('default') ? _toConsumableArray['default'] : _toConsumableArray;

    var countIntervalsBetweenNearbyPeaks = function countIntervalsBetweenNearbyPeaks(peaks) {
      var intervalBuckets = [];
      peaks.forEach(function (peak, index) {
        var length = Math.min(peaks.length - index, 10);

        var _loop = function _loop(i) {
          var interval = peaks[index + i] - peak;
          var foundInterval = intervalBuckets.some(function (intervalBucket) {
            if (intervalBucket.interval === interval) {
              intervalBucket.peaks.push(peak);
              return true;
            }

            return false;
          });

          if (!foundInterval) {
            intervalBuckets.push({
              interval: interval,
              peaks: [peak]
            });
          }
        };

        for (var i = 1; i < length; i += 1) {
          _loop(i);
        }
      });
      return intervalBuckets;
    };

    var getMaximumValue = function getMaximumValue(channelData) {
      var maximumValue = 0;
      var length = channelData.length;

      for (var i = 0; i < length; i += 1) {
        if (channelData[i] > maximumValue) {
          maximumValue = channelData[i];
        }
      }

      return maximumValue;
    };

    var getPeaksAtThreshold = function getPeaksAtThreshold(channelData, threshold, sampleRate) {
      var length = channelData.length;
      var peaks = [];
      var lastValueWasAboveThreshold = false;

      for (var i = 0; i < length; i += 1) {
        if (channelData[i] > threshold) {
          lastValueWasAboveThreshold = true;
        } else if (lastValueWasAboveThreshold) {
          lastValueWasAboveThreshold = false;
          peaks.push(i - 1); // Skip 0.25 seconds forward to get past this peak.

          i += sampleRate / 4 - 1;
        }
      } // Add the last value in the unlikely case it was peak.


      if (lastValueWasAboveThreshold) {
        peaks.push(length - 1);
      }

      return peaks;
    };

    var groupNeighborsByTempo = function groupNeighborsByTempo(intervalBuckets, sampleRate) {
      var tempoBuckets = [];
      intervalBuckets.forEach(function (intervalBucket) {
        // Convert an interval to a tempo (aka BPM).
        var theoreticalTempo = 60 / (intervalBucket.interval / sampleRate); // Adjust the tempo to fit within the 90-180 BPM range.

        while (theoreticalTempo < 90) {
          theoreticalTempo *= 2;
        }

        while (theoreticalTempo > 180) {
          theoreticalTempo /= 2;
        }

        var foundTempo = false;
        var score = intervalBucket.peaks.length;
        tempoBuckets.forEach(function (tempoBucket) {
          if (tempoBucket.tempo === theoreticalTempo) {
            tempoBucket.score += intervalBucket.peaks.length;
            tempoBucket.peaks = [].concat(_toConsumableArray(tempoBucket.peaks), _toConsumableArray(intervalBucket.peaks));
            foundTempo = true;
          }

          if (tempoBucket.tempo > theoreticalTempo - 0.5 && tempoBucket.tempo < theoreticalTempo + 0.5) {
            var tempoDifference = Math.abs(tempoBucket.tempo - theoreticalTempo) * 2;
            score += (1 - tempoDifference) * tempoBucket.peaks.length;
            tempoBucket.score += (1 - tempoDifference) * intervalBucket.peaks.length;
          }
        });

        if (!foundTempo) {
          tempoBuckets.push({
            peaks: intervalBucket.peaks,
            score: score,
            tempo: theoreticalTempo
          });
        }
      });
      return tempoBuckets;
    };

    var MINUMUM_NUMBER_OF_PEAKS = 30;
    var computeTempoBuckets = function computeTempoBuckets(channelData, sampleRate) {
      var maximumValue = getMaximumValue(channelData);
      var minimumThreshold = maximumValue * 0.3;
      var peaks = [];
      var threshold = maximumValue - maximumValue * 0.05;

      if (maximumValue > 0.25) {
        while (peaks.length < MINUMUM_NUMBER_OF_PEAKS && threshold >= minimumThreshold) {
          peaks = getPeaksAtThreshold(channelData, threshold, sampleRate);
          threshold -= maximumValue * 0.05;
        }
      }

      var intervalBuckets = countIntervalsBetweenNearbyPeaks(peaks);
      var tempoBuckets = groupNeighborsByTempo(intervalBuckets, sampleRate);
      tempoBuckets.sort(function (a, b) {
        return b.score - a.score;
      });
      return tempoBuckets;
    };

    var analyze = function analyze(channelData, sampleRate) {
      var tempoBuckets = computeTempoBuckets(channelData, sampleRate);

      if (tempoBuckets.length === 0) {
        throw new Error('The given channelData does not contain any detectable beats.');
      }

      return tempoBuckets[0].tempo;
    };

    var guess = function guess(channelData, sampleRate) {
      var tempoBuckets = computeTempoBuckets(channelData, sampleRate);

      if (tempoBuckets.length === 0) {
        throw new Error('The given channelData does not contain any detectable beats.');
      }

      var _tempoBuckets$ = tempoBuckets[0],
          peaks = _tempoBuckets$.peaks,
          tempo = _tempoBuckets$.tempo;
      var bpm = Math.round(tempo);
      var secondsPerBeat = 60 / bpm;
      peaks.sort(function (a, b) {
        return a - b;
      });
      var offset = peaks[0] / sampleRate;

      while (offset > secondsPerBeat) {
        offset -= secondsPerBeat;
      }

      return {
        bpm: bpm,
        offset: offset
      };
    };

    addEventListener('message', function (_ref) {
      var data = _ref.data;

      try {
        if (data.method === 'analyze') {
          var id = data.id,
              _data$params = data.params,
              channelData = _data$params.channelData,
              sampleRate = _data$params.sampleRate;
          var tempo = analyze(channelData, sampleRate);
          postMessage({
            error: null,
            id: id,
            result: {
              tempo: tempo
            }
          });
        } else if (data.method === 'guess') {
          var _id = data.id,
              _data$params2 = data.params,
              _channelData = _data$params2.channelData,
              _sampleRate = _data$params2.sampleRate;

          var _guess = guess(_channelData, _sampleRate),
              bpm = _guess.bpm,
              offset = _guess.offset;

          postMessage({
            error: null,
            id: _id,
            result: {
              bpm: bpm,
              offset: offset
            }
          });
        } else {
          throw new Error("The given method \"".concat(data.method, "\" is not supported"));
        }
      } catch (err) {
        postMessage({
          error: {
            message: err.message
          },
          id: data.id,
          result: null
        });
      }
    });

})));
